---
title: react - 踩坑经历
time: 2021-08-26
author: ru shui
category: framework
tag:
  - react
  - hooks
visitor: false
article: true
sticky: false
---

## Can’t perform a React state...

### 问题描述

在学习 [React17+React Hook+TS4 最佳实践仿 Jira 企业级项目](https://coding.imooc.com/class/482.html?mc_marking=9e12a70b0fad334358274d727c6587c6&mc_channel=weixin) 中遇到一个警告：

<p style="color: red;">Warning: Can’t perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in a useEffect cleanup function.</p>

显然，这是因为在组件卸载的时候，继续使用了 `setState` 方法，可能会导致内存泄露。

但是，项目开发在一半，项目的复杂性已经上来了，而且控制台的提示太模棱两可了，
bug 非常难以定位。

从其他开发者的博客中可以了解到，该问题是在组件卸载的时候，`setState` 可能会执行导致内存泄漏。
主要原因如下：

1. 在 `setTimeout` 使用了 setState，但却没有在组件卸载之前清楚定时器。
2. 在 `Promise.then` 中使用了 `setState`后，没有及时清理副作用，等到下一轮任务来临时，
   React 组件可能已经被卸载了。

### 问题重现

```tsx
import { useEffect, useState } from 'react'

const User = () => {
  const [user, setUser] = useState<{ id: number; name: string } | null>(null)

  useEffect(() => {
    setTimeout(() => {
      // The warning is generated by this code
      // If the component unmounts faster than 3s
      setUser({
        id: 1,
        name: 'John'
      })
    }, 3000)
  }, [])

  return <div>{user?.name || 'No user found'}</div>
}
const Project = () => <div>Project component</div>

const CanNotPerformExample1 = () => {
  const [activeView, setActiveView] = useState('project')

  const toggleUser = () => {
    setActiveView('user')
  }

  const toggleProject = () => {
    setActiveView('project')
  }
  return (
    <div>
      <button onClick={toggleProject}>Show project</button>
      <button onClick={toggleUser}>Show user</button>
      {activeView === 'user' ? <User /> : <Project />}
    </div>
  )
}

export const CanNotPerformExample = () => {
  return (
    <div>
      <div className="desc">
        <h1>can not perform</h1>
        <p style={{ color: 'red' }}>
          Warning: Can’t perform a React state update on an unmounted component.
          This is a no-op, but it indicates a memory leak in your application.
          To fix, cancel all subscriptions and asynchronous tasks in a useEffect
          cleanup function.
        </p>
      </div>
      <div className="examples">
        <CanNotPerformExample1 />
      </div>
    </div>
  )
}
```

![can not perform...](./images/fix-bug.gif)

在这个案例中，之所以会出现这个问题，是因为我们在切换组件的时候，`setTimeout` 中的代码还没
执行，当 `<User />` 组件卸载的时候，`setTimeout` 中的代码才开始执行，然而 `state` 已经
被回收了，所以会导致内存泄漏。

### 问题解决

#### 方案一：使用 `useEffect` cleanup

`useEffect` 为我们提供了 cleanup 的功能，只需要在 `useEffect`
的回调中返回一个 cleanup 函数即可。

```tsx
const User = () => {
  const [user, setUser] = useState<{ id: number; name: string } | null>(null)

  useEffect(() => {
    const timer = setTimeout(() => {
      // The warning is generated by this code
      // If the component unmounts faster than 3s
      setUser({
        id: 1,
        name: 'John'
      })
    }, 3000)
    return () => {
      clearTimeout(timer)
    }
  }, [])
```

#### 方案二：使用一个标识位

事实上，除了 `setTimeout` 这类定时器会触发这个警告之外，像 `Promise.then` 这类微任务也可能
触发这个警告。`Promise` 一旦承若就会执行，所以我们需要一个标识位来避免执行。

```tsx
//* Solution2
useEffect(() => {
  let isMounted = true
  setTimeout(() => {
    // The warning is generated by this code
    // If the component unmounts faster than 3s
    if (isMounted) {
      setUser({
        id: 1,
        name: 'John'
      })
    }
  }, 3000)
  return () => {
    isMounted = false
  }
}, [])
```

### 实际开发中的问题

```tsx
import { useState } from 'react'

export interface IState<D> {
  stat: 'idle' | 'loading' | 'error' | 'success'
  data: D | null
  error: Error | null
}

const defaultState: IState<null> = {
  stat: 'idle',
  data: null,
  error: null
}

const defaultConfig = {
  throwOnError: false
}

const useAsync = <D>(
  initialState?: IState<D>,
  initialConfig?: typeof defaultConfig
) => {
  initialConfig = {
    ...defaultConfig,
    ...initialConfig
  }
  const [state, setState] = useState<IState<D>>({
    ...defaultState,
    ...initialState
  })

  const setError = (error: Error) => {
    setState({
      data: null,
      stat: 'error',
      error
    })
  }

  const setData = (data: D) => {
    setState({
      data,
      error: null,
      stat: 'success'
    })
    // return data
  }

  const run = (promise: Promise<D>) => {
    if (!promise || !promise.then) {
      throw new Error(`${promise} should be a Promise type.`)
    }
    setState({ ...state, stat: 'loading' })
    return promise
      .then((data) => {
        setData(data)
        return data
      })
      .catch((e) => {
        setError(e)
        return initialConfig!.throwOnError ? Promise.reject(e) : e
        // return Promise.reject(e)
      })
  }

  return {
    isLoading: state.stat === 'loading',
    isIdle: state.stat === 'idle',
    isError: state.stat === 'error',
    isSuccess: state.stat === 'success',
    setData,
    setError,
    run,
    ...state
  }
}

export default useAsync
```

在自定义 `useAsync` hook 的时候就遇到在这种问题，主要原因还是在 `Promise.then` 和 `Promise.catch`
中使用了 `setState` 方法。

解决方法：这里需要 `useEffect` 的 cleanup 函数在组件卸载的时候执行清理操作。

1. 使用 `useRef` 缓存一个标识位。
2. 执行 cleanup 函数的时候，重置标识位即可。
3. 在使用 `setState` 的时候，先判断是否满足要求，再决定 `setState`。

```tsx
const useAsync = <D>(
  initialState?: IState<D>,
  initialConfig?: typeof defaultConfig
) => {
  // statements...
  const isMounted = useRef(true)

  useEffect(() => {
    return () => {
      isMounted.current = false
    }
  }, [isMounted])

  const run = (promise: Promise<D>) => {
    if (!promise || !promise.then) {
      throw new Error(`${promise} should be a Promise type.`)
    }
    setState({ ...state, stat: 'loading' })
    return promise
      .then((data) => {
        setData(data)
        return data
      })
      .catch((e) => {
        setError(e)
        return initialConfig!.throwOnError ? Promise.reject(e) : e
        // return Promise.reject(e)
      })
  }

  // statements...
}
```

### 小结

在使用 hooks 的时候需要注意 `setState` 的调用时机，
通常可以使用 `useEffect` 来清楚执行过程中产生的副作用。

## Reference

- [Warning: Can't Perform A React State Update On An Unmounted Component](https://www.vhudyma-blog.eu/warning-cant-perform-a-react-state-update-on-an-unmounted-component/)
